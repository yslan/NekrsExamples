@kernel void cFill(const dlong Nelements,
                   const dfloat CONST1,
                   const dfloat CONST2,
                   @restrict const dlong * eInfo,
                   @restrict dfloat * QVOL)
{ 
  for(dlong e=0;e<Nelements;++e;@outer(0)){
    const dlong solid = eInfo[e];
    for(int n=0;n<p_Np;++n;@inner(0)){
      const int id = e*p_Np + n;
      QVOL[id] = CONST1;  
      if (solid) QVOL[id] = CONST2;
    }
  }
}

@kernel void clip(const dlong Nelements,
                  const dfloat vmin,
                  const dfloat vmax,
                  @restrict dfloat * VAR)
{ 
  for(dlong e=0;e<Nelements;++e;@outer(0)){
    for(int n=0;n<p_Np;++n;@inner(0)){
      const int id = e*p_Np + n;
      if(VAR[id]>vmax) {
        VAR[id] = vmax;
      }
      if(VAR[id]<vmin) {
        VAR[id] = vmin;
      }
    }
  }
}

// P1
void rteP1Model_evalRobinForG(dfloat *out, const dfloat t)
{ 
  const dfloat hc = - P_RTE_EPS / ( 2.0 * P_RTE_TAU * (2.0 - P_RTE_EPS) );
  const dfloat tinf = t*t*t*t;
  *(out) = tinf * hc;
}   
     
void rteP1Model_evalNeumannForT(dfloat *flux, const dfloat t, const dfloat g)
{   
  const dfloat t4 = t*t*t*t;
  *(flux) = - (2.0*P_RTE_EPS) / ( P_RTE_BO * (2.0 - P_RTE_EPS) ) * (g-t4);
}     
// P1 model, rhs = T^4
@kernel void rteP1Model_compute_P1_rhs(const dlong Ntotal,
                                       @restrict const dfloat* T,
                                       @restrict dfloat* RHS)
{ 
  for (dlong n = 0; n < Ntotal; ++n; @tile(p_blockSize, @outer, @inner)) {
    if (n<Ntotal) {
      const dfloat t = T[n];
      RHS[n] = t*t*t*t;
    }
  }
} 

// P1 model, heat source = - 4 * coef * (T^4-G)
@kernel void rteP1Model_compute_T_rhs(const dlong Ntotal,
                                      @restrict const dfloat* T,
                                      @restrict const dfloat* G,
                                      @restrict dfloat* RHS)
{ 
  for (dlong n = 0; n < Ntotal; ++n; @tile(p_blockSize, @outer, @inner)) {
    if (n<Ntotal) {
      const dfloat t = T[n];
      const dfloat g = G[n];
      const dfloat t4 = t*t*t*t;
      const dfloat r = - (4.0*P_RTE_TAU/P_RTE_BO) * (t4 - g);
      RHS[n] = r;
    }
  }
}


// Boundary conditions
void velocityDirichletConditions(bcData *bc)
{
  bc->u = 0.0;
  bc->v = 0.0;
  bc->w = 1.0;
}

void scalarDirichletConditions(bcData *bc)
{
  bc->s = 1.0;
}

void scalarNeumannConditions(bcData *bc)
{
  const dfloat tloc = bc->usrwrk[bc->idM + P_RTE_TWRKID * bc->fieldOffset];
  const dfloat gloc = bc->usrwrk[bc->idM + P_RTE_GWRKID * bc->fieldOffset];

  dfloat g_flux = 0.0;
  if (bc->scalarId == P_RTE_TID)
  {
//    rteP1Model_evalNeumannForT(&g_flux, tloc, gloc);
    const dfloat t4 = tloc*tloc*tloc*tloc;
    g_flux = - (2.0*P_RTE_EPS) / ( P_RTE_BO * (2.0 - P_RTE_EPS) ) * (gloc-t4);
    if (bc->id == 3) bc->flux = 0.0  - g_flux; // side wall
    if (bc->id == 4) bc->flux = 0.01 - g_flux; // pebble surface
  }
  else if (bc->scalarId == P_RTE_GID)
  {
    if (bc->id==3 || bc->id==4) { // Robin: h1 * dudn = hc * (T - Tinf);
//      rteP1Model_evalRobinForG(&g_flux, tloc);
//      bc->flux = g_flux;
      const dfloat hc = P_RTE_EPS / ( 2.0 * P_RTE_TAU * (2.0 - P_RTE_EPS) );
      const dfloat tinf = tloc*tloc*tloc*tloc;
      bc->flux = hc * tinf;
    } else {
      bc->flux = 0.0;
    }
  }
}
